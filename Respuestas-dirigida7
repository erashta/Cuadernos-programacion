{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "0b8c2de9",
   "metadata": {},
   "source": [
    "## Algunas respuestas de la lista de ejercicios 7"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "3ce7fead",
   "metadata": {},
   "source": [
    "Escribe una clase autosuficiente llamada `Numero` que mantenga un `int`. Debe tener los\n",
    "siguientes métodos para realizar varias operaciones en el `int`:\n",
    "\n",
    "- `void establecerNumero (int n);` // establece n en int\n",
    "- `int obtenerNumero( ) ;` // devuelve el valor actual de int\n",
    "- `void imprimirNumero( ) ;` // imprime el int\n",
    "- `bool esNegativo( ) ;` // comprueba si int es negativo\n",
    "- `bool esDivisiblePor(int n);` // comprueba si int es divisible por n\n",
    "- `int valorAbsoluto( ) ;` // devuelve el valor absoluto de int"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "56142b5d",
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <stdio.h>\n",
    "#include <iostream>\n",
    "using namespace std ;\n",
    "\n",
    "class Numero\n",
    "{\n",
    "       private :\n",
    "        int num ;\n",
    "\n",
    "      public :\n",
    "      void establecerNumero ( int n )\n",
    "    {\n",
    "       num = n ;\n",
    "    }\n",
    "     int obtenerNumero( )\n",
    "    {\n",
    "        return num ;\n",
    "    }\n",
    "    void imprimirNumero( )\n",
    "    {\n",
    "        cout << num << endl ;\n",
    "         }\n",
    "\n",
    "    bool esNegativo( )\n",
    "    {\n",
    "    if ( num < 0 )\n",
    "      return true ;\n",
    "    else\n",
    "        return false ;\n",
    "    }\n",
    "    bool esDivisiblePor( int n )\n",
    "    {\n",
    "        if ( n == 0 )\n",
    "            return false ;\n",
    "        else\n",
    "        {\n",
    "            if ( num % n == 0 )\n",
    "                return true ;\n",
    "        else\n",
    "            return false ;\n",
    "    }\n",
    "       }\n",
    "    int valorAbsoluto( )\n",
    "    {\n",
    "    if ( num >= 0 )\n",
    "       return num ;\n",
    "       else\n",
    "       return -1 * num ;\n",
    "    }\n",
    "};\n",
    "int main( )\n",
    "{\n",
    "    Numero x ;\n",
    "    x.establecerNumero ( 1234 ) ;\n",
    "\n",
    "    x.imprimirNumero( ) ;\n",
    "    if ( x.esDivisiblePor( 5 ) == true )\n",
    "          cout << \"5 divide \" << x.obtenerNumero( ) << endl ;\n",
    "    else\n",
    "         cout << \"5 no divide \" << x.obtenerNumero( ) << endl ;\n",
    "    cout << \"Valor absoluto de \" << x.obtenerNumero( ) << \" is \"\n",
    "        << x.valorAbsoluto( ) << endl ;\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2a69a86d",
   "metadata": {},
   "source": [
    "Una clase autosuficiente significa que todos sus miembros están definidos dentro de la clase. Aquí, los miembros de datos y las funciones miembro de `Numero` se definen dentro de la clase.  \n",
    "\n",
    "Tal organización de la clase es sin duda factible, pero adolece de una importante limitación. Si vamos a dar esta clase a otra persona, entonces tendrá acceso al código fuente completo de la clase. Esto no es deseable, especialmente cuando está desarrollando una biblioteca de clases para que la usen otros. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "e47bde7a",
   "metadata": {},
   "source": [
    "¿Qué constructor es el constructor predeterminado? ¿Qué contiene su cuerpo?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "7a238ba5",
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <iostream>\n",
    "using namespace std ;\n",
    "\n",
    "class Muestra\n",
    "{\n",
    "};\n",
    "\n",
    "class Lanzamiento\n",
    "{\n",
    "    public :\n",
    "    Lanzamiento( )\n",
    "    {\n",
    "     cout << \"Constructor de Lanzamiento de cero argumentos\" ;\n",
    "    }\n",
    "};\n",
    "int main( )\n",
    "{\n",
    "    Muestra s ;\n",
    "    Lanzamiento t ;\n",
    "    \n",
    "    return 0 ;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6a1a151d",
   "metadata": {},
   "source": [
    "Un constructor predeterminado es el constructor de cero argumentos en una clase. Se llama constructor \"predeterminado\" porque si no lo proporcionamos, el compilador insertaría un constructor público de cero argumentos en la clase.  \n",
    "\n",
    "Aquí la clase `Muestra` no tiene constructor; por lo tanto, el compilador insertaría un constructor de cero argumentos en él. Si el compilador no hubiera hecho esto, no habríamos podido crear el objeto `s`. En la clase `Lanzamiento` hemos definido el constructor de cero argumento, por lo tanto, el compilador no proporcionaría uno. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "6638f3b4",
   "metadata": {},
   "source": [
    "¿El constructor realmente \"construye\" un objeto? ¿Se puede probar esto?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "cff0ff57",
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <iostream>\n",
    "using namespace std ;\n",
    "\n",
    "class Muestra\n",
    "{\n",
    "  public :\n",
    "  \n",
    "   Muestra( )\n",
    "   {\n",
    "      cout << \"Direccion del objeto pasado a esta función = \"\n",
    "        << this << endl ;\n",
    "    }\n",
    " };\n",
    "int main( )\n",
    "{\n",
    "   Muestra s;\n",
    "   cout << \"Direccion del objeto  s = \" << &s << endl ;\n",
    "    return 0 ;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b1b926ee",
   "metadata": {},
   "source": [
    "Constructor no asigna espacio para un objeto. En ese sentido no construye el objeto. Cuando creamos un objeto es en el enunciado  \n",
    "\n",
    "```\n",
    "Muestra s ; \n",
    "``` \n",
    " \n",
    "\n",
    "El compilador emite instrucciones equivalentes en lenguaje ensamblador para asignar espacio para el objeto y llamar al constructor. Entonces, el constructor se llama \"después\" de la asignación de espacio. Por lo tanto, no \"construye\" el objeto.  \n",
    "\n",
    "\n",
    "Esto se puede probar a través del  puntero `this`. En el programa, la dirección del objeto `s` se pasa al constructor y se recopila en el puntero `this`.  Hemos impreso el contenido del puntero `this`. \n",
    "\n",
    "Puedes observar en la ejecución  la dirección contenida en el puntero `this` es la misma que la dirección de `s` impresa en `main()`.  \n",
    "\n",
    "Esto significa que para cuando el control aterriza en el constructor, el objeto ya está creado. El constructor simplemente inicializa un objeto ya creado a los valores deseados. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "40f4951a",
   "metadata": {},
   "source": [
    " ¿Puede una clase contener múltiples constructores? En caso afirmativo, ¿cómo se pueden crear y ser utilizados? "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0f9364f7",
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <iostream>\n",
    "using namespace std ;\n",
    "\n",
    "class Muestra\n",
    "{\n",
    "  private :\n",
    "    int i ;\n",
    "    float a ;\n",
    "\n",
    " public :\n",
    "  Muestra( )\n",
    "  {\n",
    "    i=0;\n",
    "    a = 0.0 ;\n",
    "  }\n",
    "  Muestra ( int j, float b )\n",
    "  {\n",
    "   i=j;\n",
    "   a=b;\n",
    "  }\n",
    "   void imprimeData( )\n",
    "  {\n",
    "     cout << \"i = \" << i << \" a = \" << a << endl ;\n",
    "  }\n",
    "};\n",
    "\n",
    "int main( )\n",
    "{\n",
    "   Muestra s1, s2 ;\n",
    "   Muestra s3 ( 10, 3.14 ), s4 ( 20, 6.28 ) ;\n",
    "   s1.imprimeData( ) ;\n",
    "   s2.imprimeData( ) ;\n",
    "   s3.imprimeData( ) ;\n",
    "   s4.imprimeData( ) ;\n",
    "   \n",
    "   return 0 ;\n",
    "}\n",
    "\n"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "b229381c",
   "metadata": {},
   "source": [
    "Sí, una clase puede contener múltiples constructores. En La clase `Muestra` tenemos dos: un constructor de cero argumentos y un constructor de dos argumentos. Dichos constructores se denominan constructores sobrecargados. Se llama a un constructor adecuado en función de los argumentos que le estamos pasando. Por ejemplo, para `s1` y `s2` se llama al constructor de cero argumentos, mientras que para `s3` y `s4` se llama al constructor de dos argumentos."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f47cd1b9",
   "metadata": {},
   "source": [
    "¿Pueden los argumentos de un constructor tomar valores predeterminados? En caso\n",
    "afirmativo, ¿para qué serviría?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "0b3d2b33",
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <iostream>\n",
    "using namespace std ;\n",
    "class Muestra\n",
    "\n",
    "{\n",
    "  private :\n",
    "   int i ;\n",
    "   float a ;\n",
    "\n",
    "  public :\n",
    "   Muestra ( int j = 0, float b = 0.0 )\n",
    "   {\n",
    "    i=j;\n",
    "    a=b;\n",
    "  }\n",
    "  void imprimirData( )\n",
    "  {\n",
    "    cout << \"i = \" << i << \" a = \" << a << endl ;\n",
    "  }\n",
    "};\n",
    "int main( )\n",
    "{\n",
    " Muestra s1, s2 ;\n",
    " Muestra s3 ( 10, 3.14 ), s4 ( 20, 6.28 ) ;\n",
    " Muestra s5 ( 30 ), s6 ( 40 ) ;\n",
    " \n",
    " s1.imprimirData( ) ;\n",
    " s2.imprimirData( ) ;\n",
    " s3.imprimirData( ) ;\n",
    " s4.imprimirData( ) ;\n",
    " s5.imprimirData( ) ;\n",
    " s6.imprimirData( ) ;\n",
    " \n",
    " return 0 ;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "acffdb1e",
   "metadata": {},
   "source": [
    "Un constructor puede tomar valores predeterminados para sus argumentos. Mediante el uso de esta función, podríamos hacer el trabajo del constructor de cero argumentos, así como el constructor de dos argumentos en un solo constructor. Para `s5` y `s6`, `i` se configura con los valores que pasamos, mientras que `a` se configura con el valor 0.0. "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "673d11da",
   "metadata": {},
   "source": [
    "¿Cuál es el papel de un puntero **this** en un constructor?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "99d45a19",
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <iostream>\n",
    "using namespace std ;\n",
    "\n",
    "class Muestra\n",
    "\n",
    "{\n",
    "  private :\n",
    "   int i ;\n",
    "   float a ;\n",
    "  public :\n",
    "   Muestra ( int i = 0, float a = 0.0 )\n",
    "  {\n",
    "     cout << \"Direccion del objeto = \" << this << endl ;\n",
    "     this->i = i ;\n",
    "     this->a = a ;\n",
    "  }\n",
    "   void imprimirData( )\n",
    "   {\n",
    "     cout << endl << \"Direccion del objeto = \" << this << endl ;\n",
    "     cout << \"i = \" << i << \" a = \" << a << endl ;\n",
    "   }\n",
    "};\n",
    "int main( )\n",
    "{\n",
    "   Muestra s1, s2 ;\n",
    "   Muestra s3 ( 10, 3.14 ), s4 ( 20, 6.28 ) ;\n",
    "   s1.imprimirData( ) ;\n",
    "   s2.imprimirData( ) ;\n",
    "   s3.imprimirData( ) ;\n",
    "   s4.imprimirData( ) ;\n",
    "   \n",
    "   return 0 ;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "f030615c",
   "metadata": {},
   "source": [
    "Un puntero `this` siempre se pasa al constructor. Contiene la dirección del objeto que se está construyendo durante esa llamada.  \n",
    "\n",
    "\n",
    "Si los nombres de los argumentos y los nombres de las variables privadas son los mismos, entonces usando el puntero `this` podemos distinguir entre variables privadas y los argumentos. Las que se utilizan con el puntero `this`  son variables privadas."
   ]
  },
  {
   "cell_type": "markdown",
   "id": "7b9555a1",
   "metadata": {},
   "source": [
    "¿Cómo se define un constructor  copia? "
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "84f69841",
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <iostream>\n",
    "using namespace std ;\n",
    "class Circulo\n",
    "{\n",
    " private :\n",
    "   int radio ;\n",
    "   float x, y ;\n",
    "public :\n",
    "\n",
    "  Circulo( )\n",
    "  { \n",
    "  }\n",
    "    Circulo ( int rr, float xx, float yy )\n",
    "   {\n",
    "     radio = rr ;\n",
    "     x = xx ;\n",
    "     y = yy ;\n",
    "   }\n",
    "\n",
    "   Circulo ( Circulo& c )\n",
    "   {\n",
    "     cout << \"Constructor copia invocado\" << endl ;\n",
    "      radio = c.radio ;\n",
    "      x = c.x ;\n",
    "      y = c.y ;\n",
    "\n",
    "   }\n",
    "   void muestraData( )\n",
    "  {\n",
    "    cout << \"Radio = \" << radio << endl ;\n",
    "    cout << \"X-Coordenada = \" << x << endl ;\n",
    "    cout << \"Y-Coordenada = \" << y << endl ;\n",
    "  }\n",
    "};\n",
    "int main( )\n",
    "{\n",
    "  Circulo c1 ( 10, 2.5, 3.5 ) ;\n",
    "  Circulo c2 = c1 ;\n",
    "  Circulo c3 ( c1 ) ;\n",
    "\n",
    "  c1.muestraData( ) ;\n",
    "  c2.muestraData( ) ;\n",
    "  c3.muestraData( ) ;\n",
    "  return 0 ;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "1f3dd22f",
   "metadata": {},
   "source": [
    "Aquí el objeto `c1` se construye a través del constructor de tres argumentos. Los objetos `c2` y `c3` se construyen a través del constructor de copias. `c2` y `c3` no se pueden construir a través del constructor normal de tres argumentos ya que también se inicializan donde están definidos. Ten en cuenta las diferentes formas de inicialización de `c2` y `c3`. Ambos dan como resultado una llamada al constructor de copias.  \n",
    "\n",
    "Además, ten en cuenta que durante ambas llamadas, `c1` se pasa al constructor de copias por referencia. ¿Es necesario que usemos una referencia en el argumento al constructor de copias? ¿No podemos pasar un valor en su lugar? No. Porque, si pasamos el argumento por valor, su copia se construye utilizando el constructor de copias. Esto significa que el constructor de copias se llamaría a sí mismo para hacer esta copia. Este proceso continuaría hasta que el compilador se quede sin memoria. Por lo tanto, en el constructor de copias, el argumento siempre debe pasarse por referencia.  \n",
    "\n",
    "Por último, si no proporcionamos el constructor de copias, el compilador lo proporcionará. \n",
    "\n",
    " \n",
    "\n",
    " "
   ]
  },
  {
   "cell_type": "markdown",
   "id": "107d45f6",
   "metadata": {},
   "source": [
    "¿Para qué sirve un constructor copia y en qué se diferencia de un constructor normal?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "58b0be94",
   "metadata": {},
   "outputs": [],
   "source": [
    "#include <iostream>\n",
    "using namespace std ;\n",
    "\n",
    "class Circulo\n",
    " {\n",
    "  private :\n",
    "    int radio ;\n",
    "    float x, y ;\n",
    "\n",
    "  public :\n",
    "   Circulo( )\n",
    "   {\n",
    "    radio = x = y = 0 ;\n",
    "   }\n",
    "    Circulo ( int rr, float xx, float yy )\n",
    "    {\n",
    "     radio = rr ;\n",
    "     x = xx ;\n",
    "     y = yy ;\n",
    "   }\n",
    "   Circulo ( const Circulo& c )\n",
    "   {\n",
    "   cout << \"Constructor copia invocado\" << endl ;\n",
    "   radio = c.radio ;\n",
    "   x = c.x ;\n",
    "   y = c.y ;\n",
    "   }\n",
    "   void muestraData( )\n",
    "   {\n",
    "    cout << \"Radio = \" << radio << endl ;\n",
    "    cout << \"X-Coordenada = \" << x << endl ;\n",
    "    cout << \"Y-Coordenada = \" << y << endl ;\n",
    "   }\n",
    "   void colocaData ( Circulo c )\n",
    "  {\n",
    "   radio = c.radio ;\n",
    "   x = c.x ;\n",
    "   y = c.y ;\n",
    "   }\n",
    "};\n",
    "\n",
    "Circulo fun( )\n",
    "{\n",
    "   Circulo c ;\n",
    "   return c ;\n",
    "}\n",
    "\n",
    "int main( )\n",
    "{\n",
    "   Circulo c1 ( 10, 2.5, 3.5 ) ;\n",
    "   Circulo c2 = c1 ;\n",
    "   c2.muestraData( ) ;\n",
    "   Circulo c3 ;\n",
    "\n",
    "   c3.colocaData ( c1 ) ;\n",
    "   c3.muestraData( ) ;\n",
    "  \n",
    "   Circulo c4 = fun( ) ;\n",
    "   c4.muestraData( ) ;\n",
    "   return 0 ;\n",
    "}"
   ]
  },
  {
   "cell_type": "markdown",
   "id": "2c3a23a4",
   "metadata": {},
   "source": [
    "Un constructor de copias se invoca en tres situaciones. Estos son los siguientes:  \n",
    "\n",
    "\n",
    "(a) Al instanciar un objeto e inicializarlo con valores de otro objeto.   \n",
    "\n",
    "(b) Al pasar un objeto a una función por valor. \n",
    "\n",
    "(c) Cuando se devuelve un objeto de una función por valor.  \n",
    "\n",
    " \n",
    "Cuando un objeto se pasa por valor, la copia en la que opera la función se crea utilizando un constructor de copia. Si pasamos la dirección o referencia del objeto, por supuesto no se invocaría el constructor de copias, ya que en estos casos no se van a crear las copias de los objetos. \n",
    "\n",
    "Cuando se devuelve un objeto desde una función, se invoca al constructor de copias para crear una copia del valor devuelto por la función.  \n",
    "\n",
    "\n",
    "Sin embargo, a partir de la ejecución vemos que el constructor de copia se llama solo dos veces: al inicializar `c2` y al pasar `c1` a la función `colocaData()`. Contrariamente a la expectativa, no se llama cuando se crea `c4`. Esto se debe a que el compilador realiza una \"optimización del valor de retorno\" y elimina la llamada al constructor de copias para crear una copia del objeto.  \n",
    "\n",
    "Sin embargo, en algunos casos el compilador no puede realizar esta optimización. Por ejemplo, si cambia la definición a `fun()` como se muestra a continuación y vuelves a ejecutar el programa, encontrarás que esta vez se llama al constructor de copias mientras devuelve un objeto de `fun()`. \n",
    "\n",
    " \n",
    "```\n",
    "Circle fun( ) \n",
    "{ \n",
    "  Circulo cthis, cthat ; \n",
    "   int i = 0 ; \n",
    "     return ( i ? cthis : cthat ) ; \n",
    "}\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "da30df7a",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "bb8768d2",
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "272e2df7",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "C++14",
   "language": "C++14",
   "name": "xcpp14"
  },
  "language_info": {
   "codemirror_mode": "text/x-c++src",
   "file_extension": ".cpp",
   "mimetype": "text/x-c++src",
   "name": "c++",
   "version": "14"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
